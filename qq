[1mdiff --git a/modules/core/src/main/scala/tafto/service/comms/CommsService.scala b/modules/core/src/main/scala/tafto/service/comms/CommsService.scala[m
[1mindex 2ae8c31..c26cd1b 100644[m
[1m--- a/modules/core/src/main/scala/tafto/service/comms/CommsService.scala[m
[1m+++ b/modules/core/src/main/scala/tafto/service/comms/CommsService.scala[m
[36m@@ -1,13 +1,15 @@[m
 package tafto.service.comms[m
 [m
[32m+[m[32mimport scala.concurrent.duration.*[m
[32m+[m
 import tafto.domain.*[m
 import cats.effect.*[m
 import fs2.Stream[m
 import cats.data.NonEmptyList[m
[31m-import cats.MonadThrow[m
 import cats.implicits.*[m
 import cats.effect.implicits.*[m
 import io.odin.Logger[m
[32m+[m[32mimport tafto.util.Time[m
 [m
 trait CommsService[F[_]]:[m
   /** Delivery semantics - eventual at-least-once delivery. That is to say, if the effect executes successfully, the[m
[36m@@ -17,19 +19,19 @@[m [mtrait CommsService[F[_]]:[m
 [m
   def run: Stream[F, Unit][m
 [m
[31m-  def backfill: F[Unit][m
[32m+[m[32m  def backfill: Stream[F, Unit][m
 [m
[31m-  def backfillAndRun(using concurrent: Concurrent[F]): F[Unit] =[m
[32m+[m[32m  def backfillAndRun(using c: Concurrent[F]): F[Unit] =[m
     run.compile.drain.background.use { x =>[m
       for[m
[31m-        _ <- backfill[m
[32m+[m[32m        _ <- backfill.compile.drain[m
         outcome <- x[m
         result <- outcome.embedError[m
       yield result[m
     }[m
 [m
 object CommsService:[m
[31m-  def apply[F[_]: MonadThrow: Logger]([m
[32m+[m[32m  def apply[F[_]: Temporal: Logger]([m
       emailMessageRepo: EmailMessageRepo[F],[m
       emailSender: EmailSender[F][m
   ): CommsService[F] =[m
[36m@@ -85,6 +87,12 @@[m [mobject CommsService:[m
             }[m
         yield ()[m
 [m
[31m-      override val backfill: F[Unit] =[m
[31m-        emailMessageRepo.getScheduledIds.flatMap(emailMessageRepo.notify)[m
[32m+[m[32m      override val backfill: Stream[F, Unit] =[m
[32m+[m[32m        Stream.fixedRateStartImmediately(30.seconds).evalMap { _ =>[m
[32m+[m[32m          for[m[41m [m
[32m+[m[32m            now <- Time[F].utc[m
[32m+[m[32m            scheduledIds <- emailMessageRepo.getScheduledIds(now.minusMinutes(1))[m
[32m+[m[32m            _ <- emailMessageRepo.notify(scheduledIds)[m
[32m+[m[32m          yield ()[m
[32m+[m[32m        }[m
     }[m
[1mdiff --git a/modules/core/src/main/scala/tafto/service/comms/EmailMessageRepo.scala b/modules/core/src/main/scala/tafto/service/comms/EmailMessageRepo.scala[m
[1mindex 310e5ab..676706a 100644[m
[1m--- a/modules/core/src/main/scala/tafto/service/comms/EmailMessageRepo.scala[m
[1m+++ b/modules/core/src/main/scala/tafto/service/comms/EmailMessageRepo.scala[m
[36m@@ -3,11 +3,12 @@[m [mpackage tafto.service.comms[m
 import fs2.Stream[m
 import cats.data.NonEmptyList[m
 import tafto.domain.*[m
[32m+[m[32mimport java.time.OffsetDateTime[m
 [m
 trait EmailMessageRepo[F[_]]:[m
   def scheduleMessages(messages: NonEmptyList[EmailMessage]): F[List[EmailMessage.Id]][m
   def getMessage(id: EmailMessage.Id): F[Option[(EmailMessage, EmailStatus)]][m
[31m-  def getScheduledIds: F[List[EmailMessage.Id]][m
[32m+[m[32m  def getScheduledIds(scheduledAtOrBefore: OffsetDateTime): F[List[EmailMessage.Id]][m
   def claim(id: EmailMessage.Id): F[Option[EmailMessage]][m
   def markAsSent(id: EmailMessage.Id): F[Boolean][m
   def markAsError(id: EmailMessage.Id, error: String): F[Boolean][m
[1mdiff --git a/modules/integration-tests/src/test/scala/tafto/itest/CommsServiceTest.scala b/modules/integration-tests/src/test/scala/tafto/itest/CommsServiceTest.scala[m
[1mindex 3fc81a3..ab3d4b4 100644[m
[1m--- a/modules/integration-tests/src/test/scala/tafto/itest/CommsServiceTest.scala[m
[1m+++ b/modules/integration-tests/src/test/scala/tafto/itest/CommsServiceTest.scala[m
[36m@@ -104,7 +104,7 @@[m [mobject CommsServiceTest:[m
 [m
             result <- commsService.run.take(10).compile.drain.background.use { awaitFinished =>[m
               for[m
[31m-                _ <- commsService.backfill[m
[32m+[m[32m                _ <- commsService.backfill.take(1).compile.drain[m
                 streamResult <- awaitFinished[m
                 sent <- emailSender.getEmails[m
                 (sentIds, sentEmails) = sent.separate[m
[1mdiff --git a/modules/migrations/src/main/resources/db/migration/V1__Create_Users.sql b/modules/migrations/src/main/resources/db/migration/V1__Create_Users.sql[m
[1mindex 8f2c00c..085bcb9 100644[m
[1m--- a/modules/migrations/src/main/resources/db/migration/V1__Create_Users.sql[m
[1m+++ b/modules/migrations/src/main/resources/db/migration/V1__Create_Users.sql[m
[36m@@ -34,5 +34,5 @@[m [mcreate table email_messages([m
   status email_status,[m
   error text,[m
   created_at timestamptz not null,[m
[31m-  last_attempted_at timestamptz[m
[32m+[m[32m  last_updated_at timestamptz[m
 );[m
[1mdiff --git a/modules/persist/src/main/scala/tafto/persist/PgEmailMessage.scala b/modules/persist/src/main/scala/tafto/persist/PgEmailMessage.scala[m
[1mindex c1cd945..43b40c6 100644[m
[1m--- a/modules/persist/src/main/scala/tafto/persist/PgEmailMessage.scala[m
[1m+++ b/modules/persist/src/main/scala/tafto/persist/PgEmailMessage.scala[m
[36m@@ -11,5 +11,5 @@[m [mfinal case class PgEmailMessage([m
     numAttempts: Int,[m
     error: Option[String],[m
     createdAt: OffsetDateTime,[m
[31m-    lastAttemptedAt: Option[OffsetDateTime][m
[32m+[m[32m    lastUpdatedAt: Option[OffsetDateTime][m
 )[m
[1mdiff --git a/modules/persist/src/main/scala/tafto/persist/PgEmailMessageRepo.scala b/modules/persist/src/main/scala/tafto/persist/PgEmailMessageRepo.scala[m
[1mindex 5ebd9c5..ec5bf7a 100644[m
[1m--- a/modules/persist/src/main/scala/tafto/persist/PgEmailMessageRepo.scala[m
[1m+++ b/modules/persist/src/main/scala/tafto/persist/PgEmailMessageRepo.scala[m
[36m@@ -42,8 +42,8 @@[m [mfinal case class PgEmailMessageRepo[F[_]: Clock: MonadCancelThrow]([m
       s.option(EmailMessageQueries.getMessage)(id)[m
     }[m
 [m
[31m-  override val getScheduledIds: F[List[EmailMessage.Id]] = database.pool.use { s =>[m
[31m-    s.execute(EmailMessageQueries.getMessageIdsInStatus)(EmailStatus.Scheduled)[m
[32m+[m[32m  override def getScheduledIds(scheduledAtOrBefore: OffsetDateTime): F[List[EmailMessage.Id]] = database.pool.use { s =>[m
[32m+[m[32m    s.execute(EmailMessageQueries.getScheduledIds)(scheduledAtOrBefore)[m
   }[m
 [m
   override def claim(id: EmailMessage.Id): F[Option[EmailMessage]] =[m
[36m@@ -128,16 +128,17 @@[m [mobject EmailMessageQueries {[m
       select subject, to_, cc, bcc, body, status from email_messages where id = ${emailMessageId};[m
     """.query(domainEmailMessageCodec *: emailStatus)[m
 [m
[31m-  val getMessageIdsInStatus = sql"""[m
[31m-    select id from email_messages where status = ${emailStatus};[m
[32m+[m[32m  val getScheduledIds = sql"""[m
[32m+[m[32m    select id from email_messages where status = ${emailStatus} and created_at <= ${timestamptz};[m
   """.query(emailMessageId)[m
[32m+[m[32m     .contramap[OffsetDateTime] { case createdAt => (EmailStatus.Scheduled, createdAt)}[m
 [m
   val updateStatus = sql"""[m
     with ids as ([m
       select id from email_messages where id=${emailMessageId} and status=${emailStatus}[m
       for update skip locked[m
     )[m
[31m-    update email_messages m set status=${emailStatus}, last_attempted_at=${timestamptz}[m
[32m+[m[32m    update email_messages m set status=${emailStatus}, last_updated_at=${timestamptz}[m
     from ids[m
     where m.id = ids.id;[m
   """.command.contramap[UpdateStatus] { updateStatus =>[m
[36m@@ -149,7 +150,7 @@[m [mobject EmailMessageQueries {[m
       select id from email_messages where id=${emailMessageId} and status=${emailStatus}[m
       for update skip locked[m
     )[m
[31m-    update email_messages m set status=${emailStatus}, last_attempted_at=${timestamptz}, error=${text}[m
[32m+[m[32m    update email_messages m set status=${emailStatus}, last_updated_at=${timestamptz}, error=${text}[m
     from ids[m
     where m.id = ids.id;[m
   """.command.contramap[(UpdateStatus, String)] { (updateStatus, errorMessage) =>[m
[36m@@ -161,7 +162,7 @@[m [mobject EmailMessageQueries {[m
       select id from email_messages where id=${emailMessageId} and status=${emailStatus}[m
       for update skip locked[m
     )[m
[31m-    update email_messages m set status=${emailStatus}, last_attempted_at=${timestamptz}[m
[32m+[m[32m    update email_messages m set status=${emailStatus}, last_updated_at=${timestamptz}[m
     from ids[m
     where m.id = ids.id[m
     returning subject, to_, cc, bcc, body;[m
[36m@@ -171,7 +172,7 @@[m [mobject EmailMessageQueries {[m
 [m
 }[m
 [m
[31m-final case class UpdateStatus([m
[32m+[m[32mfinal case class UpdateStatus private([m
     id: EmailMessage.Id,[m
     currentStatus: EmailStatus,[m
     newStatus: EmailStatus,[m
[1mdiff --git a/modules/persist/src/test/scala/tafto/persist/PgEmailMessageRepoTests.scala b/modules/persist/src/test/scala/tafto/persist/PgEmailMessageRepoTests.scala[m
[1mindex 0aedbf2..0c175b1 100644[m
[1m--- a/modules/persist/src/test/scala/tafto/persist/PgEmailMessageRepoTests.scala[m
[1m+++ b/modules/persist/src/test/scala/tafto/persist/PgEmailMessageRepoTests.scala[m
[36m@@ -152,7 +152,8 @@[m [mobject PgEmailMessageRepoTests {[m
 [m
               for[m
                 insertedIds <- messageRepo.scheduleMessages(msgs)[m
[31m-                scheduledIds <- messageRepo.getScheduledIds[m
[32m+[m[32m                now <- Time[IO].utc[m
[32m+[m[32m                scheduledIds <- messageRepo.getScheduledIds(now)[m
               yield expect(insertedIds.toSet.subsetOf(scheduledIds.toSet))[m
             }[m
           )[m
